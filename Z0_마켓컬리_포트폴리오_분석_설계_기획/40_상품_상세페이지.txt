관리자(MyAdmin) 상품_상세페이지  & 분석 & 기획 & 설계

http://gksmf519.dothome.co.kr/myadmin
gksmf519
ming0303!


[1] 프론트앤드
    * 컴포넌트 구성(상품_상세페이지)
    * 최상위 컴폰넌트 안에 있어야 한다.
    * 상태관리 리덕스로 관리    
    * 컴포넌트 이름: ProductDetailComponent.jsx
    * 컴포넌트 이름: ProductViewComponent.jsx
    * 구현 방법 및 순서
      1. 메인페이지, 서브페이지, 기타 상품을 클릭하면 최상 본상품에 등록된다.
      2. 최근 본상품의 상품 상세내용이 페이지에 보이게 한다. => 바인딩
      3. 상품의 갯수 및 옵션을 선택 조건부 연산자

      4-1. 상품의 갯수(수량) 카운트(state.cnt) = state => cnt=1 => cnt: state.cnt+1
      4-2. 2미만이면(1이하) - minus 버튼 비활성화 시킨다.

      5. 총상품금액(state.totPay) = 상품의 갯수(수량) 카운트(state.cnt) * 상품판매가(리덕스 스토어 => selector.viewProduct.current.판매가 )

      6. 옵션을 선택하여 장바구니에 넣기전 최종 수량과 금액 계산
      7. 상품의 갯수 및 옵션을 선택하여 장바구니(카트)에 넣기한다.    
    
    
[2] 백앤드 : 
    
    - 테스트 URL
    http://gksmf519.dothome.co.kr/kurly_green/


[3] 데이터베이스
    - 관리자 자주하는 질문 테이블

    ```MYSQL        


    ```


[4] REST API 
    




 // 카운트 숫자가 1 미만이면 카운트 박스 삭제
        // 버그 초기 카운트 변수 count=[1,1,1]  
        // 순서대로 카운트 변수 값 정해짐 => 고정 fixed
        // count[0]=3  
        // count[1]=2        
        // count[2]=5

        // 셀렉트박스 선택을 하면 => 랜덤 random
        // 목록은 선택한 목록순서대로 
        // 스택구조 목록 배치

        // 스택구조에 top 값이 삭제되면
        // 두번째 선택값이 배열 top 으로 변경되면서 값이 top값으로 변경된다

        // ※ 수정보완
        // 순서대로 카운트 변수 값 정해짐 => 고정 fixed => 디버깅 => 랜덤 random
        // 셀렉트박스 리스트목록 선택을 하면 => 랜덤 random
        // 배열을 렌덤하게 생성해야한다.

        // 삭제는 리스트목록 삭제, 배열 삭제 하나로 모아서 하면 좋다.
        // 삭제시 리스트목록 랜덤하게 삭제되어야한다.
        // 삭제시 배열도 랜덤하게 삭제되어야한다.

        // 배열값이 달라지는 현상이 버그!
        if(count[idx] < 1){
            const result = list.filter((item, id)=> id !== idx);
            setList(result);
            count[idx] = 1;
            setCount([...count]);  // 세터함수 마무리
        }





//////////////////////////////////

 // 12. 장바구니 담기 클릭 이벤트
    const onClickCartAdd=(e)=>{
        e.preventDefault();
        
        // [1] 장바구니에 담을 데이터 리덕스에서 가져오기
        let 장바구니 = selector.viewProduct.current;  // 현재본상품 current {... 15개속성}
        let 단일상품장바구니 = [];
        let 다중상품장바구니 = [];
        let 카트_로컬저장소 = [];

        // [2] 단일상품 & 다중상품 조건문
        // 1. 단일상품
        if(장바구니.옵션==='단일상품'){

            // 1-1 장바구니 기존 내용에 속성 추가하기
            장바구니 = {
                ...장바구니,
                제품코드: selector.viewProduct.current.번호,
                장바구니상품명: selector.viewProduct.current.제품명, // 단일상
                수량: cnt
            }

            // 1-2 장바구니 목록 : 로컬스토레이지 저장소에서 가져오기
            if(localStorage.getItem('CART_PRODUCT')!==null){
                단일상품장바구니 = JSON.parse(localStorage.getItem('CART_PRODUCT'));
            }
    
            // 1-3 동일한 상품은 이전의 상품목록에 현재 상품이 있는지 비교하고 결과를 true, false로 반환한다.
            let imsi = 단일상품장바구니.map((item)=>item.제품코드===장바구니.제품코드); // true
    
            // 1-4 동일한 상품이 있는경우(중복된경우) => 수량: 장바구니수량 합산한다.
            if(imsi.includes(true)===true){
                단일상품장바구니 = 단일상품장바구니.map((item)=>item.제품코드===장바구니.제품코드?{...item, 수량:item.수량+장바구니.수량 }:{...item});
            }
            // 1-5 동일한 상품이 없는경우(중복된데어 없는경우) => 장바구니 추가하기
            else{
                단일상품장바구니 = [...단일상품장바구니, 장바구니];
            }

            // [3] 단일상품 & 다중상품 => Cart(장바구니 최종 넣기 완료)    
            localStorage.setItem('CART_PRODUCT', JSON.stringify(단일상품장바구니));
            setState({
                ...state, 
                장바구니: 단일상품장바구니
            });
            dispatch(cartMethod(단일상품장바구니));  


        }

        // 2. 다중상품 => 배열 [] => {}  => [{},{],{}}...]
        // 배열에 3줄 추가 => 장바구니옵션리스트[{},{},{}];
        // [
        //   {},
        //   {},
        //   {}
        // ]
        else if(장바구니.옵션==='다중상품'){
            
            // 1-1 장바구니 기존 내용을 다중상품장바구니에 추가하기
            // 리스트 옵션 여러줄(다중) => 다중상품장바구니 배열에 여러줄 추가히기
                list.map((item, i)=>{    
                    장바구니 = {
                        ...장바구니,
                        제품코드: `${selector.viewProduct.current.번호}, ${item.상품명}`,
                        장바구니상품명: item.상품명,
                        수량: count[i]
                    }            
                    다중상품장바구니 = [
                        ...다중상품장바구니,
                        장바구니
                    ]                
                }); 

            // 1-2 장바구니 목록 : 로컬스토레이지 저장소에서 가져오기
            // 이유 ? => 이전에 담아둔 카트(장바구니)에 현재 상품을 추가하기 위해서
            if(localStorage.getItem('CART_PRODUCT')!==null){
                카트_로컬저장소 = JSON.parse(localStorage.getItem('CART_PRODUCT'));             
            }

             // 1-3 로컬저장소에 담아둔 장바구니 상품목록에 현재 상품이 있는지 비교하고 
             //     결과를 true, false로 반환한다.
             //     로컬저장소[]의 제품코드 중 다중상품장바구니[]의 제품코드가 있는지 비교
            //  let res1 = null;
            //  let res = null;
            //  res1 = 카트_로컬저장소.map((item, idx)=>{  // 2개줄 => 레코드
            //     res =  다중상품장바구니.map((item2, idx)=>{ // 3개줄 => 레코드
            //         if(item.제품코드===item2.제품코드){
            //             return 1; // 중복
            //         }
            //         else{
            //             return 0; // 중복안됨
            //         }
            //     });
            //     return res; // [0], [1]
            //  });
            
            //  console.log( '중복검사 이후 출력 res1' );
            //  console.log( res1 );             
            //  console.log( `res1[0] ${res1[0]}` );
            //  console.log( `res1[1] ${res1[1]}` );
            //  console.log( res1.includes(0) );  // 검증안됨
            //  console.log( res1[0].includes(0) ); [0,0,0] true
            //  console.log( res1[1].includes(0) ); true

            //  res1.map((item, idx)=>{
            //     console.log(idx, item.includes(0) );
            //  })
            let res = null;
            // 한줄 코딩으로 리턴문없이 로컬저장소와 다중상품장바구니의 데이터 중복 비교           
            // res = 카트_로컬저장소.map((item)=>다중상품장바구니.map((item2)=>item.제품코드===item2.제품코드? 1 : 0));
            res = 카트_로컬저장소.map((item)=>다중상품장바구니.map((item2)=>item.제품코드===item2.제품코드? "같음" : "다름"));
            console.log( '한줄 코딩으로 리턴문없이 로컬저장소와 다중상품장바구니의 데이터 중복 비교 ' );
            console.log( res );
            // includes는 true false 만 반환한다.[0,0,0] => true
            // includes는 true false 만 반환한다.[0,0,0] => true
            if( res.map((item)=>item.includes("같음")).includes(true) ){ // [true, true]
                console.log( '중복됨' );
            }
            else {
                console.log( '중복안됨' );
            }


        }
       

    
      
    }